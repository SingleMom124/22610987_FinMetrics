garch_spec <- rugarch::ugarchspec(variance.model = list(model = comp[p],
garchOrder = garchOrder),
mean.model = list(armaOrder = armaOrder,
include.mean = TRUE),
distribution.model = "norm")
garch_fit <- rugarch::ugarchfit(spec = garch_spec,
data = data)
model_list[[p]] = garch_fit
}
# Putting the model criteria into a matrix to evaluate
names(model_list) <- comp
fit_mat <- sapply(model_list, infocriteria)
Model_Fits <- data.frame(Criteria = rownames(infocriteria(model_list[[1]])),
fit_mat)
#--------------------------------------------------------------------------------------
# STEP 2: Estimate the News Impact Curves
#--------------------------------------------------------------------------------------
nic_list <- list()
for (i in seq_along(model_list)) {
model <- model_list[[i]]
nic <- rugarch::newsimpact(z = NULL,
object = model)
nic_df <- cbind(nic$zx, nic$zy)
model_name <- names(model_list)[i]
colnames(nic_df) <- c("Epsilon", "Sigma")
nic_df <- data.frame(nic_df)
nic_df$Model <- rep(model_name, nrow(nic_df))
nic_list[[model_name]] <- nic_df
}
nic <- do.call(rbind, nic_list) %>%
data.frame() %>%
ggplot() +
aes(x = Epsilon,
y = Sigma,
color = Model) +
geom_line(size = 0.5) +
labs(title = "News Impact Curves") +
theme_bw()
#--------------------------------------------------------------------------------------
# STEP 3: Select the model with the best fit according the chosen selection criteria
#--------------------------------------------------------------------------------------
optimal <- Model_Fits %>%
pivot_longer(cols = -Criteria,
names_to = "Model",
values_to = "Value") %>%
filter(Criteria == fit) %>%
filter(Value == min(Value)) %>%
pull(Model)
Best_Model <- model_list[[optimal]]
# Return the three steps in a list
output <- list(Model = Best_Model,
Criteria = Model_Fits,
NIC = nic)
return(output)
}
sa_garch <- bestGARCH(data = cleaned_fx_xts$SouthAfrica,
comp = c("sGARCH","gjrGARCH","eGARCH","apARCH"),
garchOrder = c(1, 1),
armaOrder = c(1, 0),
fit = "Akaike")
sa_model <- sa_garch$Model
sa_garch$Criteria
plot(sa_garch$gjrGARCH, which = 3)
View(sa_model)
#########################################################################################
# Determine the best Uni-variate GARCH model
#########################################################################################
bestGARCH <- function(data,                                               # Series to run the models on
comp = c("sGARCH","gjrGARCH","eGARCH","apARCH"),    # Models to compare
garchOrder = c(1, 1),                               # Order of the GARCH
armaOrder = c(1, 0),                                # Order of the ARMA process
fit = "Akaike")                                     # Selection criteria
{
# There are three steps to this function
# Loading the necessary packages
library(pacman)
pacman::p_load(rugarch, huxtable, tidyverse)
#--------------------------------------------------------------------------------------
# STEP 1: Estimate the models
#--------------------------------------------------------------------------------------
models = 1:length(comp)
model_list = list()
for (p in models){
garch_spec <- rugarch::ugarchspec(variance.model = list(model = comp[p],
garchOrder = garchOrder),
mean.model = list(armaOrder = armaOrder,
include.mean = TRUE),
distribution.model = "norm")
garch_fit <- rugarch::ugarchfit(spec = garch_spec,
data = data)
model_list[[p]] = garch_fit
}
# Putting the model criteria into a matrix to evaluate
names(model_list) <- comp
fit_mat <- sapply(model_list, infocriteria)
Model_Fits <- data.frame(Criteria = rownames(infocriteria(model_list[[1]])),
fit_mat)
#--------------------------------------------------------------------------------------
# STEP 2: Estimate the News Impact Curves
#--------------------------------------------------------------------------------------
nic_list <- list()
for (i in seq_along(model_list)) {
model <- model_list[[i]]
nic <- rugarch::newsimpact(z = NULL,
object = model)
nic_df <- cbind(nic$zx, nic$zy)
model_name <- names(model_list)[i]
colnames(nic_df) <- c("Epsilon", "Sigma")
nic_df <- data.frame(nic_df)
nic_df$Model <- rep(model_name, nrow(nic_df))
nic_list[[model_name]] <- nic_df
}
nic <- do.call(rbind, nic_list) %>%
data.frame() %>%
ggplot() +
aes(x = Epsilon,
y = Sigma,
color = Model) +
geom_line(size = 0.5) +
labs(title = "News Impact Curves") +
theme_bw()
#--------------------------------------------------------------------------------------
# STEP 3: Select the model with the best fit according the chosen selection criteria
#--------------------------------------------------------------------------------------
optimal <- Model_Fits %>%
pivot_longer(cols = -Criteria,
names_to = "Model",
values_to = "Value") %>%
filter(Criteria == fit) %>%
filter(Value == min(Value)) %>%
pull(Model)
Best_Model <- model_list[[optimal]]
# Return the three steps in a list
output <- list(Model = Best_Model,
Criteria = Model_Fits,
NIC = nic)
names(output)[names(output) == "Model"] <- optimal
return(output)
}
sa_garch <- bestGARCH(data = cleaned_fx_xts$SouthAfrica,
comp = c("sGARCH","gjrGARCH","eGARCH","apARCH"),
garchOrder = c(1, 1),
armaOrder = c(1, 0),
fit = "Akaike")
sa_model <- sa_garch$Model
sa_garch$Criteria
plot(sa_garch$gjrGARCH, which = 3)
View(sa_garch)
sa_garch$Criteria
sa_garch$NIC
plot(sa_garch$gjrGARCH, which = 3)
sa_garch$Criteria
fmxdat::finplot(sa_garch$NIC)
plot(sa_garch$gjrGARCH, which = 3)
EstimateGOGARCH <- function(data,
type,
garchOrder = c(1, 1),
armaOrder = c(1, 0)){
library(pacman)
p_load(rugarch, rmgarch, xts, tidyverse, ggplot2)
# First specify a univariate GARCH
uni_specifications <- rugarch::ugarchspec(variance.model = list(model = type,
garchOrder = garchOrder),
mean.model = list(armaOrder = armaOrder,
include.mean = T),
distribution.model = "sstd")
# Second, repeat it n times so each series is fitted with the specified GARCH
multi_specifications <- rugarch::multispec(replicate(ncol(data), uni_specifications))
# Third, push this through to a Go-GARCH specification
go_specification <- rmgarch::gogarchspec(multi_specifications,
distribution.model = "mvnorm",
ica = "fastica")
# Fourth, fit a milti-variable model
multiple <- rugarch::multifit(multi_specifications,
data,
cluster = makePSOCKcluster(10))
# Can now fit the Go-GARCH
gogarch <- rmgarch::gogarchfit(spec = go_specification,
data = data,
solver = "hybrid",
cluster = makePSOCKcluster(10),
gfun = "tanh",
maxiter1 = 40000,
epsilon = 1e-08,
rseed = 100)
# From this we can extract the sigmas and time varying correlations
Sigma <- gogarch@mfit$factor.sigmas
TV_Cor <- rcor(gogarch)
TV_Cor <- aperm(TV_Cor, c(3,2,1))
dim(TV_Cor) <- c(nrow(TV_Cor), ncol(TV_Cor)^2)
# This has kak naming though so fix it with the following function
output <- list(Sigma = Sigma,
TV_Cor = TV_Cor)
return(output)
}
estimateGOGARCH <- function(data,
type,
garchOrder = c(1, 1),
armaOrder = c(1, 0)){
library(pacman)
p_load(rugarch, rmgarch, xts, tidyverse, ggplot2)
# First specify a univariate GARCH
uni_specifications <- rugarch::ugarchspec(variance.model = list(model = type,
garchOrder = garchOrder),
mean.model = list(armaOrder = armaOrder,
include.mean = T),
distribution.model = "sstd")
# Second, repeat it n times so each series is fitted with the specified GARCH
multi_specifications <- rugarch::multispec(replicate(ncol(data), uni_specifications))
# Third, push this through to a Go-GARCH specification
go_specification <- rmgarch::gogarchspec(multi_specifications,
distribution.model = "mvnorm",
ica = "fastica")
# Fourth, fit a milti-variable model
multiple <- rugarch::multifit(multi_specifications,
data,
cluster = makePSOCKcluster(10))
# Can now fit the Go-GARCH
gogarch <- rmgarch::gogarchfit(spec = go_specification,
data = data,
solver = "hybrid",
cluster = makePSOCKcluster(10),
gfun = "tanh",
maxiter1 = 40000,
epsilon = 1e-08,
rseed = 100)
# From this we can extract the sigmas and time varying correlations
Sigma <- gogarch@mfit$factor.sigmas
TV_Cor <- rcor(gogarch)
TV_Cor <- aperm(TV_Cor, c(3,2,1))
dim(TV_Cor) <- c(nrow(TV_Cor), ncol(TV_Cor)^2)
# This has kak naming though so fix it with the following function
output <- list(Sigma = Sigma,
TV_Cor = TV_Cor)
return(output)
}
gogarch <- estimateGOGARCH(data = cleaned_fx_xts,
type = "gjrGARCH")
sigma <- gogarch$Sigma
View(sigma)
colnames(sigma) <- colnames(cleaned_fx_xts)
sigma <- gogarch$Sigma
colnames(sigma) <- colnames(cleaned_fx_xts)
fmxdat::finplot(sigma %>%
tbl_xts() %>%
pivot_longer(cols = -date,
names_to = "Currency",
values_to = "Vol") %>%
ggplot() +
geom_line(aes(x = date,
y = Sigma,
color = Currency)) +
facet_wrap(~ Currency,
scales = "free_y"))
sigma <- gogarch$Sigma
colnames(sigma) <- colnames(cleaned_fx_xts)
sigma %>%
xts_tbl() %>%
pivot_longer(cols = -date,
names_to = "Currency",
values_to = "Vol") %>%
ggplot() +
geom_line(aes(x = date,
y = Sigma,
color = Currency)) +
facet_wrap(~ Currency,
scales = "free_y")
sigma <- gogarch$Sigma
sigma <- gogarch$Sigma
colnames(sigma) <- colnames(cleaned_fx_xts)
sigma <- cbind(date = index(cleaned_fx_xts), sigma) %>%
pivot_longer(cols = -date,
names_to = "Currency",
values_to = "Vol") %>%
ggplot() +
geom_line(aes(x = date,
y = Sigma,
color = Currency)) +
facet_wrap(~ Currency,
scales = "free_y")
sigma <- gogarch$Sigma
colnames(sigma) <- colnames(cleaned_fx_xts)
sigma <- cbind(date = index(cleaned_fx_xts), sigma)
sigma <- gogarch$Sigma
colnames(sigma) <- colnames(cleaned_fx_xts)
sigma <- cbind(date = index(cleaned_fx_xts), sigma) %>%
mutate(date = as.Date(date)) %>%
pivot_longer(cols = -date,
names_to = "Currency",
values_to = "Vol") %>%
ggplot() +
geom_line(aes(x = date,
y = Sigma,
color = Currency)) +
facet_wrap(~ Currency,
scales = "free_y")
sigma <- gogarch$Sigma
colnames(sigma) <- colnames(cleaned_fx_xts)
sigma <- cbind(date = index(cleaned_fx_xts), sigma) %>%
data.frame() %>%
mutate(date = as.Date(date)) %>%
pivot_longer(cols = -date,
names_to = "Currency",
values_to = "Vol") %>%
ggplot() +
geom_line(aes(x = date,
y = Sigma,
color = Currency)) +
facet_wrap(~ Currency,
scales = "free_y")
sigma <- gogarch$Sigma
colnames(sigma) <- colnames(cleaned_fx_xts)
sigma <- cbind(date = index(cleaned_fx_xts), sigma) %>%
data.frame() %>%
mutate(date = as.Date(date)) %>%
pivot_longer(cols = -date,
names_to = "Currency",
values_to = "Vol")
sigma %>%
ggplot() +
geom_line(aes(x = date,
y = Sigma,
color = Currency)) +
facet_wrap(~ Currency,
scales = "free_y")
sigma %>%
ggplot() +
geom_line(aes(x = date,
y = Vol,
color = Currency)) +
facet_wrap(~ Currency,
scales = "free_y")
fmxdat::finplot(sigma %>%
ggplot() +
geom_line(aes(x = date,
y = Vol,
color = Currency)) +
facet_wrap(~ Currency,
scales = "free_y"))
fmxdat::finplot(sigma %>%
ggplot() +
geom_line(aes(x = date,
y = Vol,
color = Currency)) +
facet_wrap(~ Currency,
scales = "free_y")) +
theme_bw()
pairs <- gogarch$TV_Cor
View(pairs)
pairs <- renameMGARCH(series = cleaned_fx_xts,
pairs = pairs,
long = T)
View(pairs)
pairs <- gogarch$TV_Cor
pairs <- renameMGARCH(series = cleaned_fx_xts,
pairs = pairs,
long = T)
ggplot(pairs %>% dplyr::filter(grepl("SouthAfrica_", Pairs),
!grepl("_SouthAfrica", Pairs))) +
geom_line(aes(x = date,
y = Rho,
color = Pairs)) +
theme_bw() +
ggtitle("Go-GARCH: SA")
fmxdat::finplot(ggplot(pairs %>% dplyr::filter(grepl("SouthAfrica_", Pairs),
!grepl("_SouthAfrica", Pairs))) +
geom_line(aes(x = date,
y = Rho,
color = Pairs)) +
theme_bw() +
ggtitle("Go-GARCH: SA"))
fmxdat::finplot(ggplot(pairs %>% dplyr::filter(grepl("SouthAfrica_", Pairs), !grepl("_SouthAfrica", Pairs))) +
geom_line(aes(x = date,
y = Rho,
color = Pairs)) +
facet_wrap(~ Pairs)
theme_bw() +
fmxdat::finplot(ggplot(pairs %>% dplyr::filter(grepl("SouthAfrica_", Pairs), !grepl("_SouthAfrica", Pairs))) +
geom_line(aes(x = date,
y = Rho,
color = Pairs)) +
facet_wrap(~ Pairs) +
theme_bw() +
ggtitle("Go-GARCH: SA"))
fmxdat::finplot(sigma %>%
ggplot() +
geom_line(aes(x = date,
y = Vol,
color = Currency)) +
facet_wrap(~ Currency,
scales = "free_y")) +
theme_bw()
View(sigma)
sigma_mean <- sigma %>%
group_by(Currency) %>%
mutate(Mean_Vol = mean(Vol, na.rm = T)) %>%
dplyr::select(-date, -Vol) %>%
unique()
View(sigma_mean)
sigma_mean <- sigma %>%
group_by(Currency) %>%
mutate(Mean_Vol = mean(Vol, na.rm = T)) %>%
dplyr::select(-date, -Vol) %>%
unique() %>%
arrange(Mean_Vol)
sigma_mean <- sigma %>%
group_by(Currency) %>%
mutate(Mean_Vol = mean(Vol, na.rm = T)) %>%
dplyr::select(-date, -Vol) %>%
unique() %>%
arrange(Mean_Vol)
#################################################################################
# Estimate a GOGARCH Model
#################################################################################
estimateGOGARCH <- function(data,                   # Data to investigate
type,                   # Type of GARCH you want to apply across the series
garchOrder = c(1, 1),
armaOrder = c(1, 0)){
library(pacman)
p_load(rugarch, rmgarch, xts, tidyverse, ggplot2)
# First specify a univariate GARCH
uni_specifications <- rugarch::ugarchspec(variance.model = list(model = type,
garchOrder = garchOrder),
mean.model = list(armaOrder = armaOrder,
include.mean = T),
distribution.model = "sstd")
# Second, repeat it n times so each series is fitted with the specified GARCH
multi_specifications <- rugarch::multispec(replicate(ncol(data), uni_specifications))
# Third, push this through to a Go-GARCH specification
go_specification <- rmgarch::gogarchspec(multi_specifications,
distribution.model = "mvnorm",
ica = "fastica")
# Fourth, fit a multi-variable model
multiple <- rugarch::multifit(multi_specifications,
data,
cluster = makePSOCKcluster(10))
# Can now fit the Go-GARCH
gogarch <- rmgarch::gogarchfit(spec = go_specification,
data = data,
solver = "hybrid",
cluster = makePSOCKcluster(10),
gfun = "tanh",
maxiter1 = 40000,
epsilon = 1e-08,
rseed = 100)
# From this we can extract the sigmas and time varying correlations
Sigma <- sigma(gogarch)
TV_Cor <- rcor(gogarch)
TV_Cor <- aperm(TV_Cor, c(3,2,1))
dim(TV_Cor) <- c(nrow(TV_Cor), ncol(TV_Cor)^2)
# This has kak naming though so fix it with the following function
output <- list(Sigma = Sigma,
TV_Cor = TV_Cor)
return(output)
}
gogarch <- estimateGOGARCH(data = cleaned_fx_xts,
type = "gjrGARCH")
# Now plotting the volatilities
sigma <- gogarch$Sigma
colnames(sigma) <- colnames(cleaned_fx_xts)
sigma <- cbind(date = index(cleaned_fx_xts), sigma) %>%
data.frame() %>%
mutate(date = as.Date(date)) %>%
pivot_longer(cols = -date,
names_to = "Currency",
values_to = "Vol")
gogarch <- estimateGOGARCH(data = cleaned_fx_xts,
type = "gjrGARCH")
# Now plotting the volatilities
sigma <- gogarch$Sigma
colnames(sigma) <- colnames(cleaned_fx_xts)
sigma <- sigma %>%
xts_tbl() %>%
pivot_longer(cols = -date,
names_to = "Currency",
values_to = "Vol")
fmxdat::finplot(sigma %>%
ggplot() +
geom_line(aes(x = date,
y = Vol,
color = Currency)) +
facet_wrap(~ Currency,
scales = "free_y")) +
theme_bw()
# And the correlation pairs
# The output here has super kak naming though so adjust with the following function
pairs <- gogarch$TV_Cor
pairs <- renameMGARCH(series = cleaned_fx_xts,
pairs = pairs,
long = T)
fmxdat::finplot(ggplot(pairs %>% dplyr::filter(grepl("SouthAfrica_", Pairs), !grepl("_SouthAfrica", Pairs))) +
geom_line(aes(x = date,
y = Rho,
color = Pairs)) +
facet_wrap(~ Pairs) +
theme_bw() +
ggtitle("Go-GARCH: SA"))
# Average vol
sigma_mean <- sigma %>%
group_by(Currency) %>%
mutate(Mean_Vol = mean(Vol, na.rm = T)) %>%
dplyr::select(-date, -Vol) %>%
unique() %>%
arrange(desc(Mean_Vol))
library(gt)
library(gt)
sigma_mean %>%
gt() %>%
tab_header(title = glue::glue("Mean perod volatility"))
gt(sigma_mean)
View(cncy_carry)
View(bbdxy)
