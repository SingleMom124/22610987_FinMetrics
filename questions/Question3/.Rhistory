ALSI_Cap1 <- indexCAP(data = returns,
rebalance = ALSI_Reb,
cap = 0.05,
name = "5% Cap")
ALSI_Cap2 <- indexCAP(data = returns,
rebalance = ALSI_Reb,
cap = 0.1,
name = "10% Cap")
ALSI_Cap1 <- indexCAP(data = returns,
rebalance = ALSI_Reb,
cap = 0.05,
name = "ALSI 5% Cap")
ALSI_Cap2 <- indexCAP(data = returns,
rebalance = ALSI_Reb,
cap = 0.1,
name = "ALSI 10% Cap")
SWIX_Cap1 <- indexCAP(data = returns,
rebalance = SWIX_Reb,
cap = 0.05,
name = "SWIX 5% Cap")
SWIX_Cap2 <- indexCAP(data = returns,
rebalance = SWIX_Reb,
cap = 0.1,
name = "SWIX 10% Cap")
capped_indices <- ALSI_Cap1 %>%
inner_join(ALSI_Cap2, by = "date") %>%
inner_join(SWIX_Cap1, by = "date") %>%
inner_join(SWIX_Cap2, by = "date") %>%
inner_join(indices, by = "date")
View(capped_indices)
View(ALSI_Cap1)
View(indexCAP)
indexCAP <- function(data,       # Returns data. Need to be only three columns, date, return, and tickers
rebalance,  # Re-balance data. Also only three columns, date, tickers, and weight
cap,        # The size of the cap
name)       # Index name
{
# First using another function to determine what need to be rebalanced and when
rebalancer <- function(data,
cap)
{
# First establishing a specific format for the data
if( !"weight" %in% names(data)) stop("... for Calc capping to work, provide weight column called 'weight' in the rebalance argument")
if( !"date" %in% names(data)) stop("... for Calc capping to work, provide date column called 'date' in the rebalance argument")
if( !"tickers" %in% names(data)) stop("... for Calc capping to work, provide id column called 'tickers' in the rebalance argument")
# Now identify the indices breaching the cap
breachers <- data %>% filter(weight > cap) %>% pull(tickers)
if(length(breachers) > 0) {
while(data %>% filter(weight > cap) %>% nrow() > 0 ) {
data <-bind_rows(data %>% filter(tickers %in% breachers) %>% mutate(weight = cap),
data %>% filter(!tickers %in% breachers) %>% mutate(weight = (weight / sum(weight, na.rm = T)) * (1 - length(breachers) * cap)))
breachers <- c(breachers, data %>% filter(weight > cap) %>% pull(tickers))
}
if( sum(data$weight, na.rm=T) > 1.001 | sum(data$weight, na.rm=T) < 0.999 | max(data$weight, na.rm = T) > cap) {
stop("Issue with summing the weights")
}
} else {
}
data
}
if( !"rebalance_time" %in% names(rebalance)) stop("... for Calc capping to work, provide a rebalance dates column called 'rebalance_time' in the rebalance argument")
Capped_df <- rebalance  %>%
group_split(rebalance_time) %>%
map_df(~rebalancer(.,
cap = cap) ) %>%
dplyr::select(-rebalance_time)
# Now use this to create index returns
# First getting the weights
wts <- Capped_df %>%
tbl_xts(cols_to_xts = weight,
spread_by = tickers)
wts[is.na(wts)] <- 0
if( !"return" %in% names(data)) stop("... for Calc capping to work, provide return column called 'return' in the data argument")
if( !"date" %in% names(data)) stop("... for Calc capping to work, provide date column called 'date' in the data argument")
if( !"tickers" %in% names(data)) stop("... for Calc capping to work, provide id column called 'tickers' in the data argument")
if(ncol(data) > 3) stop("... too many columns in the data argument, supply only `date`, `tickers`, and `return` columns")
# Then the returns
rts <- data %>%
tbl_xts(cols_to_xts = return,
spread_by = tickers)
rts[is.na(rts)] <- 0
# Putting both into the portfolio function
index <- rmsfuns::Safe_Return.portfolio(R = rts,
weights = wts,
lag_weights = T) %>%
xts_tbl() %>%
rename(Portfolio = portfolio.returns)
colnames(index)[2] <- name
}
ALSI_Cap1 <- indexCAP(data = returns,
rebalance = ALSI_Reb,
cap = 0.05,
name = "ALSI 5% Cap")
ALSI_Cap2 <- indexCAP(data = returns,
rebalance = ALSI_Reb,
cap = 0.1,
name = "ALSI 10% Cap")
SWIX_Cap1 <- indexCAP(data = returns,
rebalance = SWIX_Reb,
cap = 0.05,
name = "SWIX 5% Cap")
SWIX_Cap2 <- indexCAP(data = returns,
rebalance = SWIX_Reb,
cap = 0.1,
name = "SWIX 10% Cap")
capped_indices <- ALSI_Cap1 %>%
inner_join(ALSI_Cap2, by = "date") %>%
inner_join(SWIX_Cap1, by = "date") %>%
inner_join(SWIX_Cap2, by = "date") %>%
inner_join(indices, by = "date")
name <- "bruh"
name[1]
indexCAP <- function(data,       # Returns data. Need to be only three columns, date, return, and tickers
rebalance,  # Re-balance data. Also only three columns, date, tickers, and weight
cap,        # The size of the cap
name)       # Index name
{
# First using another function to determine what need to be rebalanced and when
rebalancer <- function(data,
cap)
{
# First establishing a specific format for the data
if( !"weight" %in% names(data)) stop("... for Calc capping to work, provide weight column called 'weight' in the rebalance argument")
if( !"date" %in% names(data)) stop("... for Calc capping to work, provide date column called 'date' in the rebalance argument")
if( !"tickers" %in% names(data)) stop("... for Calc capping to work, provide id column called 'tickers' in the rebalance argument")
# Now identify the indices breaching the cap
breachers <- data %>% filter(weight > cap) %>% pull(tickers)
if(length(breachers) > 0) {
while(data %>% filter(weight > cap) %>% nrow() > 0 ) {
data <-bind_rows(data %>% filter(tickers %in% breachers) %>% mutate(weight = cap),
data %>% filter(!tickers %in% breachers) %>% mutate(weight = (weight / sum(weight, na.rm = T)) * (1 - length(breachers) * cap)))
breachers <- c(breachers, data %>% filter(weight > cap) %>% pull(tickers))
}
if( sum(data$weight, na.rm=T) > 1.001 | sum(data$weight, na.rm=T) < 0.999 | max(data$weight, na.rm = T) > cap) {
stop("Issue with summing the weights")
}
} else {
}
data
}
if( !"rebalance_time" %in% names(rebalance)) stop("... for Calc capping to work, provide a rebalance dates column called 'rebalance_time' in the rebalance argument")
Capped_df <- rebalance  %>%
group_split(rebalance_time) %>%
map_df(~rebalancer(.,
cap = cap) ) %>%
dplyr::select(-rebalance_time)
# Now use this to create index returns
# First getting the weights
wts <- Capped_df %>%
tbl_xts(cols_to_xts = weight,
spread_by = tickers)
wts[is.na(wts)] <- 0
if( !"return" %in% names(data)) stop("... for Calc capping to work, provide return column called 'return' in the data argument")
if( !"date" %in% names(data)) stop("... for Calc capping to work, provide date column called 'date' in the data argument")
if( !"tickers" %in% names(data)) stop("... for Calc capping to work, provide id column called 'tickers' in the data argument")
if(ncol(data) > 3) stop("... too many columns in the data argument, supply only `date`, `tickers`, and `return` columns")
# Then the returns
rts <- data %>%
tbl_xts(cols_to_xts = return,
spread_by = tickers)
rts[is.na(rts)] <- 0
# Putting both into the portfolio function
index <- rmsfuns::Safe_Return.portfolio(R = rts,
weights = wts,
lag_weights = T) %>%
xts_tbl() %>%
rename(name[2] = portfolio.returns)
ALSI_Cap1 <- indexCAP(data = returns,
rebalance = ALSI_Reb,
cap = 0.05,
name = "ALSI 5% Cap")
indexCAP <- function(data,       # Returns data. Need to be only three columns, date, return, and tickers
rebalance,  # Re-balance data. Also only three columns, date, tickers, and weight
cap,        # The size of the cap
name)       # Index name
{
# First using another function to determine what need to be rebalanced and when
rebalancer <- function(data,
cap)
{
# First establishing a specific format for the data
if( !"weight" %in% names(data)) stop("... for Calc capping to work, provide weight column called 'weight' in the rebalance argument")
if( !"date" %in% names(data)) stop("... for Calc capping to work, provide date column called 'date' in the rebalance argument")
if( !"tickers" %in% names(data)) stop("... for Calc capping to work, provide id column called 'tickers' in the rebalance argument")
# Now identify the indices breaching the cap
breachers <- data %>% filter(weight > cap) %>% pull(tickers)
if(length(breachers) > 0) {
while(data %>% filter(weight > cap) %>% nrow() > 0 ) {
data <-bind_rows(data %>% filter(tickers %in% breachers) %>% mutate(weight = cap),
data %>% filter(!tickers %in% breachers) %>% mutate(weight = (weight / sum(weight, na.rm = T)) * (1 - length(breachers) * cap)))
breachers <- c(breachers, data %>% filter(weight > cap) %>% pull(tickers))
}
if( sum(data$weight, na.rm=T) > 1.001 | sum(data$weight, na.rm=T) < 0.999 | max(data$weight, na.rm = T) > cap) {
stop("Issue with summing the weights")
}
} else {
}
data
}
if( !"rebalance_time" %in% names(rebalance)) stop("... for Calc capping to work, provide a rebalance dates column called 'rebalance_time' in the rebalance argument")
Capped_df <- rebalance  %>%
group_split(rebalance_time) %>%
map_df(~rebalancer(.,
cap = cap) ) %>%
dplyr::select(-rebalance_time)
# Now use this to create index returns
# First getting the weights
wts <- Capped_df %>%
tbl_xts(cols_to_xts = weight,
spread_by = tickers)
wts[is.na(wts)] <- 0
if( !"return" %in% names(data)) stop("... for Calc capping to work, provide return column called 'return' in the data argument")
if( !"date" %in% names(data)) stop("... for Calc capping to work, provide date column called 'date' in the data argument")
if( !"tickers" %in% names(data)) stop("... for Calc capping to work, provide id column called 'tickers' in the data argument")
if(ncol(data) > 3) stop("... too many columns in the data argument, supply only `date`, `tickers`, and `return` columns")
# Then the returns
rts <- data %>%
tbl_xts(cols_to_xts = return,
spread_by = tickers)
rts[is.na(rts)] <- 0
# Putting both into the portfolio function
index <- rmsfuns::Safe_Return.portfolio(R = rts,
weights = wts,
lag_weights = T) %>%
xts_tbl() %>%
rename(portfolio = portfolio.returns)
}
ALSI_Cap1 <- indexCAP(data = returns,
rebalance = ALSI_Reb,
cap = 0.05,
name = "ALSI 5% Cap")
View(ALSI_Cap1)
colnames(ALSI_Cap1)[2] <- name[1]
View(ALSI_Cap1)
indexCAP <- function(data,       # Returns data. Need to be only three columns, date, return, and tickers
rebalance,  # Re-balance data. Also only three columns, date, tickers, and weight
cap,        # The size of the cap
name)       # Index name
{
# First using another function to determine what need to be rebalanced and when
rebalancer <- function(data,
cap)
{
# First establishing a specific format for the data
if( !"weight" %in% names(data)) stop("... for Calc capping to work, provide weight column called 'weight' in the rebalance argument")
if( !"date" %in% names(data)) stop("... for Calc capping to work, provide date column called 'date' in the rebalance argument")
if( !"tickers" %in% names(data)) stop("... for Calc capping to work, provide id column called 'tickers' in the rebalance argument")
# Now identify the indices breaching the cap
breachers <- data %>% filter(weight > cap) %>% pull(tickers)
if(length(breachers) > 0) {
while(data %>% filter(weight > cap) %>% nrow() > 0 ) {
data <-bind_rows(data %>% filter(tickers %in% breachers) %>% mutate(weight = cap),
data %>% filter(!tickers %in% breachers) %>% mutate(weight = (weight / sum(weight, na.rm = T)) * (1 - length(breachers) * cap)))
breachers <- c(breachers, data %>% filter(weight > cap) %>% pull(tickers))
}
if( sum(data$weight, na.rm=T) > 1.001 | sum(data$weight, na.rm=T) < 0.999 | max(data$weight, na.rm = T) > cap) {
stop("Issue with summing the weights")
}
} else {
}
data
}
if( !"rebalance_time" %in% names(rebalance)) stop("... for Calc capping to work, provide a rebalance dates column called 'rebalance_time' in the rebalance argument")
Capped_df <- rebalance  %>%
group_split(rebalance_time) %>%
map_df(~rebalancer(.,
cap = cap) ) %>%
dplyr::select(-rebalance_time)
# Now use this to create index returns
# First getting the weights
wts <- Capped_df %>%
tbl_xts(cols_to_xts = weight,
spread_by = tickers)
wts[is.na(wts)] <- 0
if( !"return" %in% names(data)) stop("... for Calc capping to work, provide return column called 'return' in the data argument")
if( !"date" %in% names(data)) stop("... for Calc capping to work, provide date column called 'date' in the data argument")
if( !"tickers" %in% names(data)) stop("... for Calc capping to work, provide id column called 'tickers' in the data argument")
if(ncol(data) > 3) stop("... too many columns in the data argument, supply only `date`, `tickers`, and `return` columns")
# Then the returns
rts <- data %>%
tbl_xts(cols_to_xts = return,
spread_by = tickers)
rts[is.na(rts)] <- 0
# Putting both into the portfolio function
index <- rmsfuns::Safe_Return.portfolio(R = rts,
weights = wts,
lag_weights = T) %>%
xts_tbl() %>%
rename(portfolio = portfolio.returns)
colnames(index)[2] <- name[1]
}
ALSI_Cap1 <- indexCAP(data = returns,
rebalance = ALSI_Reb,
cap = 0.05,
name = "ALSI 5% Cap")
ALSI_Cap2 <- indexCAP(data = returns,
rebalance = ALSI_Reb,
cap = 0.1,
name = "ALSI 10% Cap")
SWIX_Cap1 <- indexCAP(data = returns,
rebalance = SWIX_Reb,
cap = 0.05,
name = "SWIX 5% Cap")
SWIX_Cap2 <- indexCAP(data = returns,
rebalance = SWIX_Reb,
cap = 0.1,
name = "SWIX 10% Cap")
capped_indices <- ALSI_Cap1 %>%
inner_join(ALSI_Cap2, by = "date") %>%
inner_join(SWIX_Cap1, by = "date") %>%
inner_join(SWIX_Cap2, by = "date") %>%
inner_join(indices, by = "date")
View(indexCAP)
indexCAP <- function(data,       # Returns data. Need to be only three columns, date, return, and tickers
rebalance,  # Re-balance data. Also only three columns, date, tickers, and weight
cap)        # The size of the cap
# First using another function to determine what need to be rebalanced and when
rebalancer <- function(data,
cap)
{
# First establishing a specific format for the data
if( !"weight" %in% names(data)) stop("... for Calc capping to work, provide weight column called 'weight' in the rebalance argument")
if( !"date" %in% names(data)) stop("... for Calc capping to work, provide date column called 'date' in the rebalance argument")
if( !"tickers" %in% names(data)) stop("... for Calc capping to work, provide id column called 'tickers' in the rebalance argument")
# Now identify the indices breaching the cap
breachers <- data %>% filter(weight > cap) %>% pull(tickers)
if(length(breachers) > 0) {
while(data %>% filter(weight > cap) %>% nrow() > 0 ) {
data <-bind_rows(data %>% filter(tickers %in% breachers) %>% mutate(weight = cap),
data %>% filter(!tickers %in% breachers) %>% mutate(weight = (weight / sum(weight, na.rm = T)) * (1 - length(breachers) * cap)))
breachers <- c(breachers, data %>% filter(weight > cap) %>% pull(tickers))
}
if( sum(data$weight, na.rm=T) > 1.001 | sum(data$weight, na.rm=T) < 0.999 | max(data$weight, na.rm = T) > cap) {
stop("Issue with summing the weights")
}
} else {
}
data
}
if( !"rebalance_time" %in% names(rebalance)) stop("... for Calc capping to work, provide a rebalance dates column called 'rebalance_time' in the rebalance argument")
Capped_df <- rebalance  %>%
group_split(rebalance_time) %>%
map_df(~rebalancer(.,
cap = cap) ) %>%
dplyr::select(-rebalance_time)
indexCAP <- function(data,       # Returns data. Need to be only three columns, date, return, and tickers
rebalance,  # Re-balance data. Also only three columns, date, tickers, and weight
cap)        # The size of the cap
# First using another function to determine what need to be rebalanced and when
rebalancer <- function(data,
cap)
{
# First establishing a specific format for the data
if( !"weight" %in% names(data)) stop("... for Calc capping to work, provide weight column called 'weight' in the rebalance argument")
if( !"date" %in% names(data)) stop("... for Calc capping to work, provide date column called 'date' in the rebalance argument")
if( !"tickers" %in% names(data)) stop("... for Calc capping to work, provide id column called 'tickers' in the rebalance argument")
# Now identify the indices breaching the cap
breachers <- data %>% filter(weight > cap) %>% pull(tickers)
if(length(breachers) > 0) {
while(data %>% filter(weight > cap) %>% nrow() > 0 ) {
data <-bind_rows(data %>% filter(tickers %in% breachers) %>% mutate(weight = cap),
data %>% filter(!tickers %in% breachers) %>% mutate(weight = (weight / sum(weight, na.rm = T)) * (1 - length(breachers) * cap)))
breachers <- c(breachers, data %>% filter(weight > cap) %>% pull(tickers))
}
if( sum(data$weight, na.rm=T) > 1.001 | sum(data$weight, na.rm=T) < 0.999 | max(data$weight, na.rm = T) > cap) {
stop("Issue with summing the weights")
}
} else {
}
data
}
if( !"rebalance_time" %in% names(rebalance)) stop("... for Calc capping to work, provide a rebalance dates column called 'rebalance_time' in the rebalance argument")
Capped_df <- rebalance  %>%
group_split(rebalance_time) %>%
map_df(~rebalancer(.,
cap = cap) ) %>%
dplyr::select(-rebalance_time)
indexCAP <- function(data,       # Returns data. Need to be only three columns, date, return, and tickers
rebalance,  # Re-balance data. Also only three columns, date, tickers, and weight
cap)        # The size of the cap
{
# First using another function to determine what need to be rebalanced and when
rebalancer <- function(data,
cap)
{
# First establishing a specific format for the data
if( !"weight" %in% names(data)) stop("... for Calc capping to work, provide weight column called 'weight' in the rebalance argument")
if( !"date" %in% names(data)) stop("... for Calc capping to work, provide date column called 'date' in the rebalance argument")
if( !"tickers" %in% names(data)) stop("... for Calc capping to work, provide id column called 'tickers' in the rebalance argument")
# Now identify the indices breaching the cap
breachers <- data %>% filter(weight > cap) %>% pull(tickers)
if(length(breachers) > 0) {
while(data %>% filter(weight > cap) %>% nrow() > 0 ) {
data <-bind_rows(data %>% filter(tickers %in% breachers) %>% mutate(weight = cap),
data %>% filter(!tickers %in% breachers) %>% mutate(weight = (weight / sum(weight, na.rm = T)) * (1 - length(breachers) * cap)))
breachers <- c(breachers, data %>% filter(weight > cap) %>% pull(tickers))
}
if( sum(data$weight, na.rm=T) > 1.001 | sum(data$weight, na.rm=T) < 0.999 | max(data$weight, na.rm = T) > cap) {
stop("Issue with summing the weights")
}
} else {
}
data
}
if( !"rebalance_time" %in% names(rebalance)) stop("... for Calc capping to work, provide a rebalance dates column called 'rebalance_time' in the rebalance argument")
Capped_df <- rebalance  %>%
group_split(rebalance_time) %>%
map_df(~rebalancer(.,
cap = cap) ) %>%
dplyr::select(-rebalance_time)
# Now use this to create index returns
# First getting the weights
wts <- Capped_df %>%
tbl_xts(cols_to_xts = weight,
spread_by = tickers)
wts[is.na(wts)] <- 0
if( !"return" %in% names(data)) stop("... for Calc capping to work, provide return column called 'return' in the data argument")
if( !"date" %in% names(data)) stop("... for Calc capping to work, provide date column called 'date' in the data argument")
if( !"tickers" %in% names(data)) stop("... for Calc capping to work, provide id column called 'tickers' in the data argument")
if(ncol(data) > 3) stop("... too many columns in the data argument, supply only `date`, `tickers`, and `return` columns")
# Then the returns
rts <- data %>%
tbl_xts(cols_to_xts = return,
spread_by = tickers)
rts[is.na(rts)] <- 0
# Putting both into the portfolio function
index <- rmsfuns::Safe_Return.portfolio(R = rts,
weights = wts,
lag_weights = T) %>%
xts_tbl() %>%
rename(portfolio = portfolio.returns)
}
ALSI_Cap1 <- indexCAP(data = returns,
rebalance = ALSI_Reb,
cap = 0.05)
colnames(ALSI_Cap1)[2] <- "ALSI 5% Cap"
ALSI_Cap2 <- indexCAP(data = returns,
rebalance = ALSI_Reb,
cap = 0.1)
colnames(ALSI_Cap2)[2] <- "ALSI 10% Cap"
SWIX_Cap1 <- indexCAP(data = returns,
rebalance = SWIX_Reb,
cap = 0.05)
colnames(SWIX_Cap1)[2] <- "SWIX 5% Cap"
SWIX_Cap2 <- indexCAP(data = returns,
rebalance = SWIX_Reb,
cap = 0.1)
colnames(SWIX_Cap1)[2] <- "SWIX 10% Cap"
capped_indices <- ALSI_Cap1 %>%
inner_join(ALSI_Cap2, by = "date") %>%
inner_join(SWIX_Cap1, by = "date") %>%
inner_join(SWIX_Cap2, by = "date") %>%
inner_join(indices, by = "date")
View(capped_indices)
SWIX_Cap2 <- indexCAP(data = returns,
rebalance = SWIX_Reb,
cap = 0.1)
colnames(SWIX_Cap2)[2] <- "SWIX 10% Cap"
capped_indices <- ALSI_Cap1 %>%
inner_join(ALSI_Cap2, by = "date") %>%
inner_join(SWIX_Cap1, by = "date") %>%
inner_join(SWIX_Cap2, by = "date") %>%
inner_join(indices, by = "date")
chart.CumReturns(R = capped_indices,
main = "Portfolios cumulative returns",
legend.loc = "topleft",
colorset = c("steelblue", "orange"))
chart.CumReturns(R = capped_indices,
main = "Portfolios cumulative returns",
legend.loc = "topleft")
chart.CumReturns(R = capped_indices %>% dplyr::select(-ALSI, - `ALSI 5% Cap`, -`ALSI 10% Cap`),
main = "SWIX cumulative returns",
legend.loc = "topleft")
chart.CumReturns(R = capped_indices %>% dplyr::select(-SWIX, - `SWIX 5% Cap`, -`SWIX 10% Cap`),
main = "ALSI cumulative returns",
legend.loc = "topleft")
chart.CumReturns(R = capped_indices %>% dplyr::select(-SWIX, - `SWIX 5% Cap`, -`SWIX 10% Cap`),
main = "ALSI cumulative returns",
legend.loc = "topleft")
View(capped_indices)
ALSI_Cap1 <- indexCAP(data = returns,
rebalance = ALSI_Reb,
cap = 0.05)
colnames(ALSI_Cap1)[2] <- "ALSI 5% Cap"
ALSI_Cap2 <- indexCAP(data = returns,
rebalance = ALSI_Reb,
cap = 0.1)
colnames(ALSI_Cap2)[2] <- "ALSI 10% Cap"
SWIX_Cap1 <- indexCAP(data = returns,
rebalance = SWIX_Reb,
cap = 0.05)
colnames(SWIX_Cap1)[2] <- "SWIX 5% Cap"
SWIX_Cap2 <- indexCAP(data = returns,
rebalance = SWIX_Reb,
cap = 0.1)
colnames(SWIX_Cap2)[2] <- "SWIX 10% Cap"
capped_indices <- ALSI_Cap1 %>%
inner_join(ALSI_Cap2, by = "date") %>%
inner_join(SWIX_Cap1, by = "date") %>%
inner_join(SWIX_Cap2, by = "date") %>%
inner_join(indices, by = "date") %>%
tbl_xts()
chart.CumReturns(R = capped_indices %>% dplyr::select(-ALSI, - `ALSI 5% Cap`, -`ALSI 10% Cap`),
main = "SWIX cumulative returns",
legend.loc = "topleft")
View(capped_indices)
chart.CumReturns(R = capped_indices[, c(1, 2, 5)],
main = "ALSI cumulative returns",
legend.loc = "topleft")
chart.CumReturns(R = capped_indices[, c(3, 4, 6)],
main = "SWIX cumulative returns",
legend.loc = "topleft")
